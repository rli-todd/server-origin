using System;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Text;
using Solishine.CommonLib;

namespace Aci.X.DalGen
{
  class DalGen
  {
    static void Main(string[] args)
    {
      if (args == null || args.Length != 5)
      {
        Console.WriteLine("Usage:\n");
        Console.Write("DbMethodEmitter <output_path> <db_assembly_path>  <namespace> <db_class_name> <stored_proc_classname>");
        return;
      }
      try
      {
        DalGen dalGen = new DalGen(
          strOutputPath: Path.GetFullPath(args[0]),
          strDbAssemblyPath: Path.GetFullPath(args[1]),
          strNamespace: args[2],
          strDbBaseClass: args[3],
          strSpBaseClass: args[4]);
        dalGen.Emit();
        // Indicate a successful completion
        Environment.Exit(0);
      }
      catch (Exception ex)
      {
        Console.WriteLine("{0} at {1}", ex.Message, ex.StackTrace);
        // Indicate a failed completion
        Environment.Exit(1);
      }
    }

    private static string _strAssemblyFolder;

    private const string DEFAULT_DB_NAME = "DefaultDB";
    private string _strNamespace;
    private string _strDbBaseClass;
    private string _strSpBaseClass;
    private Assembly _dbAssembly;
    private StreamWriter _swOutput;

    public DalGen(
      string strOutputPath,
      string strDbAssemblyPath,
      string strNamespace,
      string strDbBaseClass,
      string strSpBaseClass)
    {
      _strNamespace = strNamespace;
      _strDbBaseClass = strDbBaseClass;
      _strSpBaseClass = strSpBaseClass;
      _dbAssembly = Assembly.LoadFile(strDbAssemblyPath);
      _swOutput = new StreamWriter(strOutputPath, false);

      _strAssemblyFolder = Path.GetDirectoryName(Path.GetFullPath(strDbAssemblyPath));
      var appDomain = AppDomain.CurrentDomain;
      appDomain.AssemblyResolve += new ResolveEventHandler(MyResolver);

    }

    static Assembly MyResolver(object sender, ResolveEventArgs args)
    {
      string assemblyPath = Path.Combine(_strAssemblyFolder, new AssemblyName(args.Name).Name + ".dll");
      if (File.Exists(assemblyPath) == false) return null;
      Assembly assembly = Assembly.LoadFrom(assemblyPath);
      return assembly;
    }

    public void Emit(bool boolUseDefaultDB = false, bool boolAllowMultiDbAssociation = false)
    {
      _swOutput.WriteLine("/**********************************************************************************");
      _swOutput.WriteLine("**");
      _swOutput.WriteLine("** The classes in this source file were generated by Aci.X.DalGen ");
      _swOutput.WriteLine("** on {0:yyyy-MM-dd} at {0:HH:mm:ss} and should not be modified directly.", DateTime.Now);
      _swOutput.WriteLine("**");
      _swOutput.WriteLine("***********************************************************************************/");

      // First get a list of all "database" classes we will need to generate
      Dictionary<string, string> dictDbNames = new Dictionary<string, string>();
      foreach (Type type in _dbAssembly.GetTypes())
      {
        MySpGroupAttribute[] tags = type.GetCustomAttributes<MySpGroupAttribute>().ToArray();
        if (tags.Length > 0)
        {
          if (boolAllowMultiDbAssociation == false && tags[0].Groups.Length > 1)
          {
            throw new Exception(type.Name + " cannot be associated with multiple databases");
          }
          foreach (string strTag in tags[0].Groups)
          {
            dictDbNames[strTag] = null;
          }
        }
      }
      if (boolUseDefaultDB)
      {
        dictDbNames[DEFAULT_DB_NAME] = null;
      }

      Dictionary<string, string> dictReferencedNamespaces = new Dictionary<string, string>();
      dictReferencedNamespaces.Add("System.Data.SqlClient", null);
      StringBuilder sb = new StringBuilder();

      foreach (string strDbName in dictDbNames.Keys)
      {
        EmitDbClass(sb, dictReferencedNamespaces, strDbName);
      }
      foreach (string strRefNamespace in dictReferencedNamespaces.Keys)
      {
        _swOutput.WriteLine("using {0};", strRefNamespace);
      }
      _swOutput.WriteLine("namespace {0}", _strNamespace);
      _swOutput.WriteLine("{");
      _swOutput.Write(sb.ToString());
      _swOutput.WriteLine("}");
      _swOutput.Close();
    }

    private void EmitDbClass(
      StringBuilder sb,
      Dictionary<string, string> dictReferencedNamespaces,
      string strDbName)
    {
      sb.AppendLine("  /// <summary");
      sb.AppendFormat("  /// This class auto-generated by: {0}\r\n", Assembly.GetExecutingAssembly().GetName().Name);
      sb.AppendLine("  /// </summary");
      sb.AppendFormat("  public partial class {0} : {1}\r\n", strDbName, _strDbBaseClass);
      sb.AppendLine("  {");
      sb.AppendFormat("    public {0}(SqlConnection conn=null, bool boolUseTransaction=false, int intCommandTimeoutSecs=0) : base(conn, boolUseTransaction, intCommandTimeoutSecs)\r\n", strDbName);
      sb.AppendLine("    { }");
      Type[] methodTypes = (
        from t in _dbAssembly.GetTypes()
        where (t.Namespace.StartsWith(_strNamespace)
          && (HasMySpGroupAttribute(t, strDbName) || (strDbName == DEFAULT_DB_NAME && t.Namespace == _strNamespace))
          && t.BaseType.Name == _strSpBaseClass)
        select t).ToArray();
      for (int idxMethod = 0; idxMethod < methodTypes.Length; ++idxMethod)
      {
        Type type = methodTypes[idxMethod];
        EmitMethod(sb, dictReferencedNamespaces, strDbName, type);
      }
      sb.AppendLine("  }");
      sb.AppendLine();
    }

    private bool HasMySpGroupAttribute(Type type, string strDbName)
    {
      MySpGroupAttribute[] tags = type.GetCustomAttributes<MySpGroupAttribute>().ToArray();
      return tags != null && tags.Length > 0 && tags[0].Groups.Contains(strDbName);
    }

    /// <summary>
    /// Generates a method to access a stored procedure.
    /// </summary>
    /// <param name="sb"></param>
    /// <param name="dictReferencedNamespaces"></param>
    /// <param name="typeStoredProc"></param>
    private void EmitMethod(StringBuilder sb, Dictionary<string, string> dictReferencedNamespaces, string strDbName, Type typeStoredProc)
    {
      foreach (var method in typeStoredProc.GetMethods())
      {
        if (method.Name == "Execute")
        {
          if (!dictReferencedNamespaces.ContainsKey(method.ReturnParameter.ParameterType.Namespace))
            dictReferencedNamespaces[method.ReturnParameter.ParameterType.Namespace] = null;

          ParameterInfo[] paramInfos = method.GetParameters();
          sb.AppendFormat("    /// <summary>\r\n    /// {0}.{1}\r\n    /// </summary>\r\n", strDbName,
            typeStoredProc.Name);
          sb.AppendFormat("    public {0} {1}(",
            GetTypeName(method.ReturnParameter.ParameterType),
            typeStoredProc.Name);
          for (int idxParam = 0; idxParam < paramInfos.Length; ++idxParam)
          {
            ParameterInfo pInfo = paramInfos[idxParam];
            if (!dictReferencedNamespaces.ContainsKey(pInfo.ParameterType.Namespace))
              dictReferencedNamespaces[pInfo.ParameterType.Namespace] = null;
            if (paramInfos.Length > 1)
              sb.Append("\r\n      ");
            sb.AppendFormat("{0}{1} {2}{3}{4}",
              ParamPrefix(pInfo),
              GetTypeName(pInfo.ParameterType),
              pInfo.Name,
              pInfo.HasDefaultValue
              ? ("=" + GetDefaultValue(pInfo.ParameterType.Name, pInfo.DefaultValue))
              : "",
              idxParam < (paramInfos.Length - 1) ? "," : "");
          }

          ConstructorInfo ciConstructorWithTran = typeStoredProc.GetConstructor(
            bindingAttr: BindingFlags.Instance | BindingFlags.Public,
            binder: null,
            types: new Type[] { typeof(DbConnection), typeof(DbTransaction) },
            modifiers: null);

          ConstructorInfo ciConstructorWithTimeout = typeStoredProc.GetConstructor(
            bindingAttr: BindingFlags.Instance | BindingFlags.Public,
            binder: null,
            types: new Type[] { typeof(DbConnection), typeof(DbTransaction), typeof(Int32) },
            modifiers: null);
          sb.AppendFormat(")\r\n    {{\r\n      {0}new {1}(_conn{2}{3})\r\n        .Execute(",
            method.ReturnParameter.ParameterType == typeof(void)
              ? ""
              : "return ",
            typeStoredProc.Name,
            (ciConstructorWithTran != null || ciConstructorWithTimeout != null ? ",Transaction" : ""),
            (ciConstructorWithTimeout != null ? ",CommandTimeoutSecs" : ""));
          for (int idxParam = 0; idxParam < paramInfos.Length; ++idxParam)
          {
            sb.AppendFormat("{0}{1}: {2}{1}{3}",
              paramInfos.Length == 1 ? "" : "\r\n          ",
              paramInfos[idxParam].Name,
              ParamPrefix(paramInfos[idxParam]),
              idxParam < (paramInfos.Length - 1) ? "," : "");
          }
          sb.Append(");\r\n    }\r\n");
          sb.AppendLine();
        }
      }
    }

    private string ParamPrefix(ParameterInfo pInfo)
    {
      return pInfo.IsOut
        ? "out "
        : pInfo.ParameterType.IsByRef
          ? "ref "
          : "";
    }

    private string GetTypeName(Type t)
    {
      string strTypeName = t.Name;
      if (t.IsArray)
        return GetTypeName(t.GetElementType()) + "[]";

      if (t.IsByRef)
        return GetTypeName(Type.GetType(t.FullName.Replace("&", "")));

      if (strTypeName == "Nullable`1")
        return GetTypeName(t.GenericTypeArguments[0]) + "?";

      if (t.IsGenericType)
      {
        StringBuilder sb = new StringBuilder(strTypeName.Substring(0, strTypeName.IndexOf('`')) + "<");
        for (int idxParam = 0; idxParam < t.GenericTypeArguments.Length; ++idxParam)
        {
          if (idxParam > 0)
            sb.Append(',');
          sb.Append(GetTypeName(t.GenericTypeArguments[idxParam]));
        }
        sb.Append('>');
        return sb.ToString();
      }

      switch (strTypeName)
      {
        case "Decimal":
          return "decimal";
        case "Byte":
          return "byte";
        case "Int16":
          return "short";
        case "Int32":
          return "int";
        case "Int64":
          return "long";
        case "UInt16":
          return "ushort";
        case "UInt32":
          return "uint";
        case "UInt64":
          return "ulong";
        case "Boolean":
          return "bool";
        case "String":
          return "string";
        case "Void":
          return "void";
        default:
          return t.Name.ToString();
      }
    }

    private string GetDefaultValue(string strTypeName, object oDefaultValue)
    {
      if (oDefaultValue == null)
        return "null";
      else if (strTypeName == "String")
        return @"""" + oDefaultValue.ToString() + @"""";
      else if (strTypeName == "Boolean")
        return oDefaultValue.ToString().ToLower();
      else
        return oDefaultValue.ToString();
    }
  }



}